<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="">
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="#">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->
        
        <script>
        


 var buildTree = function(inorder, postorder) {
  return dfs(inorder.length - 1, 0, inorder.length - 1);

  function dfs(index, startPos, endPos) {
    if (startPos > endPos)
      return null;
//在后序遍历中找到根节点
    var node = new TreeNode(postorder[index]);
    //找到根节点的下标和初始位置
    var pos = inorder.indexOf(postorder[index], startPos);
//因为后序的最后一个总是根结点，令pos在中序中找到该根结点，则pos把中序分为两部分，左边是左子树，右边是右子树。因为是输出先序（根左右），所以先打印出当前根结点，然后打印左子树，再打印右子树。
//左子树在后序中的根结点为index – (endPos – pos + 1)，即为当前根结点-右子树的个数。左子树在中序中的起始点start为start，末尾endPos点为pos – 1.右子树的根结点为当前根结点的前一个结点index – 1，右子树的起始点start为pos+1，末尾endPos点为endPos。
    node.left = dfs(index - (endPos - pos) - 1, startPos, pos - 1);
    node.right = dfs(index - 1, pos + 1, endPos);

    return node;
  }
};


var buildTree = function (inorder, postorder) {

function dfs(il, ir, pl, pr) {
  if (il > ir || pl > pr) return null;

  let root = new TreeNode(postorder[pr])

  let k = inorder.indexOf(postorder[pr])

  root.left = dfs(il, k - 1, pl, pl + k - il - 1)
  root.right = dfs(k + 1, ir, pl + k - il, pr - 1)

  return root
}

return dfs(0, inorder.length - 1, 0, postorder.length - 1)
};




var buildTree = function(inorder, postorder) {
    let binaryTree = {}
   
  const iteration = (postorder, inorder, tree) => {
       
      if (!postorder.length) {
          binaryTree = null
          return
      }
       
      tree.val = null
      tree.left = {
          val: null,
          left: null,
          right: null
      }
      tree.right = {
          val: null,
          left: null,
          right: null
      }

     // 前序遍历第一个节点为当前树的根节点
     let rootVal = postorder.splice(postorder.length - 1, 1)[0]
     // 中序遍历根节点的索引
     let rootIndex = inorder.indexOf(rootVal)
     // 中序遍历的左子树
     let inorderLeftTree = inorder.slice(0, rootIndex)
     // 中序遍历的右子树
     let inorderRightTree = inorder.slice(rootIndex + 1)
     // 前序遍历的左子树
     let postorderLeftTree = postorder.slice(0, inorderLeftTree.length)
     // 前序遍历的右子树
     let postorderRightTree = postorder.slice(inorderLeftTree.length)

       
     tree.val = rootVal
      
     if (postorderLeftTree.length === 1 || inorderLeftTree.length === 1) {
         tree.left.val = postorderLeftTree[0]
     } else if (postorderLeftTree.length > 1 || inorderLeftTree.length > 1) {
         iteration(postorderLeftTree, inorderLeftTree, tree.left)
     } else {
          tree.left = null
     }
       

     if (postorderRightTree.length === 1 || inorderRightTree.length === 1) {
         tree.right.val = postorderRightTree[0]
     } else if (postorderRightTree.length > 1 || inorderRightTree.length > 1) {
         iteration(postorderRightTree, inorderRightTree, tree.right)
     } else {
      tree.right = null
     }
  }
   
  iteration(postorder, inorder, binaryTree)
   
  return binaryTree
};

        
        </script>
    </body>
</html>